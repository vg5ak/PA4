
package mjparser;
import ast.node.*;
import java_cup.runtime.*;
import java.util.*;
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.File;
import java.io.FileNotFoundException;
import exceptions.*;


parser code {:

    public PrintWriter out;

    public String programName;

    public void unrecovered_syntax_error(Symbol cur_SymbolValue) {
        report_fatal_error("Fatal syntax error", cur_SymbolValue);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        done_parsing();
        Symbol SymbolValue = (Symbol)info;
        mjparser.SymbolValue tok = (mjparser.SymbolValue)SymbolValue.value;
        throw new mjparser.ParseException("Fatal parsing error",
                                          tok.line, tok.pos);
    }

    public void report_error(String message, Object info) {
        Symbol SymbolValue = (Symbol)info;
        mjparser.SymbolValue tok = (mjparser.SymbolValue)SymbolValue.value;
        System.err.println("[" + tok.line + "," + tok.pos + "] "
                               + message + " at " + tok.toString() );
    }

:}

/* Notice: all terminals declared here */
terminal SymbolValue PLUS, MINUS, TIMES, LPAREN, RPAREN;
terminal SymbolValue LBRACE, RBRACE;
terminal SymbolValue BOOLEAN, INT;
terminal SymbolValue BYTE;
terminal SymbolValue MAIN, IMPORT;
terminal SymbolValue IF, ELSE;
terminal SymbolValue LT;
terminal SymbolValue EQUAL;
terminal SymbolValue AND, NOT;
terminal SymbolValue WHILE;
terminal SymbolValue COMMA, DOT;
terminal SymbolValue NEW, PUBLIC, RETURN, STATIC;
terminal SymbolValue STRING, VOID;
terminal SymbolValue CLASS, EXTENDS;
terminal SymbolValue LBRACKET, RBRACKET;
terminal SymbolValue LENGTH;
terminal SymbolValue SEMI;
terminal SymbolValue ASSIGN;

terminal SymbolValue MEGGY;
terminal SymbolValue MEGGYCOLOR;
terminal SymbolValue MEGGYBUTTON;
terminal SymbolValue MEGGYTONE;
terminal SymbolValue MEGGYSETPIXEL;
terminal SymbolValue MEGGYSETAUXLEDS;
terminal SymbolValue MEGGYTONESTART;
terminal SymbolValue MEGGYDELAY;
terminal SymbolValue MEGGYGETPIXEL;
terminal SymbolValue MEGGYCHECKBUTTON;

terminal SymbolValue INT_LITERAL, ID;
terminal SymbolValue TRUE, FALSE;
terminal SymbolValue COLOR_LITERAL, BUTTON_LITERAL, TONE_LITERAL;
terminal SymbolValue THIS;

/* bogus terminal for unary precedence declaration */
terminal UMINUS;

non terminal Program program;
non terminal IExp exp;
non terminal IStatement statement;
non terminal List<IStatement> statement_list;
non terminal MainClass main_class;
non terminal IStatement block_statement;
non terminal IdLiteral identifier;
non terminal List<IExp> arguments;
non terminal IExp return;
non terminal LinkedList<Formal> formals;
non terminal IType type;
non terminal MethodDecl method_declaration;
non terminal IClassDecl class_declaration;
non terminal LinkedList<IClassDecl> class_list;
non terminal LinkedList<MethodDecl> method_list;
/* Declare precedence and associativity  here */
precedence left TIMES, LT;
precedence left EQUAL;
precedence left AND;
precedence left PLUS;
precedence left MINUS;
precedence left EQUAL;
precedence left ELSE;
precedence left DOT;
//precedence left COMMENT;


precedence right NOT;
precedence right ELSE;
precedence right BYTE;
precedence right UMINUS;
precedence right IMPORT;
precedence right CLASS;
precedence right LPAREN;
precedence right RPAREN;



/* Meggy Java Grammar */
start with program;

program ::=
    IMPORT:i MEGGY SEMI main_class:m class_list:c
    {:RESULT = new Program(i.line, i.pos, m, c);:}
    ;
type ::=
     BOOLEAN:x {:RESULT = new BoolType(x.line, x.pos);:}
    |BYTE:x {:RESULT = new ByteType(x.line, x.pos);:}
    |INT:x {:RESULT = new IntType(x.line, x.pos);:}
    |VOID:x {:RESULT = new VoidType(x.line, x.pos);:}
    |MEGGYCOLOR:x {:RESULT = new ColorType(x.line, x.pos);:}
    |MEGGYTONE:x {:RESULT = new ToneType(x.line, x.pos);:}
    |MEGGYBUTTON:x {:RESULT = new ButtonType(x.line, x.pos);:}
    ;
exp ::=
     exp:a AND:op exp:b {:RESULT = new AndExp(op.line, op.pos, a, b);:}
    |exp:a EQUAL:op exp:b {:RESULT = new EqualExp(op.line, op.pos, a, b);:}
    |exp:a PLUS:op exp:b {:RESULT = new PlusExp(op.line, op.pos, a, b);:}
    |exp:a MINUS:op exp:b {:RESULT = new MinusExp(op.line, op.pos, a, b);:}
    |exp:a TIMES:op exp:b {:RESULT = new MulExp(op.line, op.pos, a, b);:}
    |exp:a LT:op exp:b  {: RESULT = new LtExp(op.line, op.pos, a, b); :}
    | MINUS:op exp:b {: RESULT = new NegExp(op.line, op.pos, b);:}%prec UMINUS
    |MEGGYGETPIXEL LPAREN exp:a COMMA exp:b RPAREN:op
    {: RESULT = new MeggyGetPixel(op.line, op.pos, a,b);
    :}
    |MEGGYCHECKBUTTON LPAREN exp:a RPAREN:op
    {: RESULT = new MeggyCheckButton(op.line, op.pos, a);
    :}
    |LPAREN BYTE RPAREN exp:a
    {: RESULT = new ByteCast(a.getLine(), a.getPos(), (IExp)a);

    :}%prec BYTE
    | INT_LITERAL:a
    {: RESULT = new IntLiteral(a.line, a.pos, a.lexeme, a.value);

    :}
    | COLOR_LITERAL:b
    {: RESULT = new ColorLiteral(b.line, b.pos, b.lexeme, b.value);

    :}
    | BUTTON_LITERAL:a
    {: RESULT = new ButtonLiteral(a.line, a.pos, a.lexeme, a.value);:}
    | TONE_LITERAL:t {: RESULT = new ToneLiteral(t.line, t.pos, t.lexeme, t.value); :}
    | TRUE:t {:RESULT = new TrueLiteral(t.line, t.pos, t.lexeme, t.value);:}
    | FALSE:t {:RESULT = new FalseLiteral(t.line, t.pos, t.lexeme, t.value);:}
    | NOT:op exp:a {: RESULT = new NotExp(op.line, op.pos, a);:}
    | LPAREN exp:a RPAREN{: RESULT = a;:}
    | identifier:i {:RESULT = i;:}
    | THIS:t {:RESULT = new ThisLiteral(t.line, t.pos, t.lexeme, t.value);:}
    | NEW:n identifier:id LPAREN RPAREN {:RESULT = new NewExp(n.line, n.pos, id.getLexeme());:}
    |exp:a DOT identifier:i LPAREN arguments:args RPAREN
    {:
        RESULT = new CallExp(a.getLine(), a.getPos(), a, i.getLexeme(), args);
    :}//%prec DOT

    ;
statement ::=
    LBRACE:l statement_list:a RBRACE {:RESULT = new BlockStatement(l.line,l.pos,a);:}
    |MEGGYSETPIXEL:m LPAREN exp:a COMMA exp:b COMMA exp:c RPAREN SEMI
    {: RESULT = new MeggySetPixel(m.line, m.pos, a, b, c);

    :}
    |MEGGYDELAY:m LPAREN exp:a RPAREN SEMI
    {: RESULT = new MeggyDelay(m.line, m.pos, a);:}
    |IF:op LPAREN exp:a RPAREN statement:b
    {: RESULT = new IfStatement(op.line, op.pos, a, b, null);:}
    |IF:op LPAREN exp:a RPAREN statement:b ELSE statement:c
    {: RESULT = new IfStatement(op.line, op.pos, a, b, c);:}
    |WHILE:op LPAREN exp:a RPAREN statement:b
    {: RESULT = new WhileStatement(op.line, op.pos, a, b);:}
    |exp:a DOT identifier:i LPAREN arguments:args RPAREN SEMI
    {:
        RESULT = new CallStatement(a.getLine(), a.getPos(), a, i.getLexeme(), args);
    :}//%prec DOT
    | MEGGYTONESTART:m LPAREN exp:a COMMA exp:b RPAREN SEMI
    {: RESULT = new MeggyToneStart(m.line, m.pos, a, b); :}
    ;
statement_list ::=
     statement_list:s1 statement:s2
     {: s1.add(s2); RESULT = s1;:}
    |{:RESULT = new LinkedList<IStatement>();:}
    ;
identifier ::=
    ID:id
    {: RESULT = new IdLiteral(id.line, id.pos, id.lexeme);:}
    ;

block_statement ::=
    LBRACE:l statement_list:s1 RBRACE
      {:RESULT = new BlockStatement(l.line, l.pos, s1);:}
    ;
formals ::=
    formals:fo COMMA:c type:t identifier:i
    {: Formal formal = new Formal(t.getLine(), t.getPos(), t, i.getLexeme());
        fo.add(formal);
        RESULT = fo;
    :}
    |type:t identifier:i
    {:  Formal formal2 = new Formal(t.getLine(), t.getPos(), t, i.getLexeme());
        LinkedList<Formal> fo = new LinkedList<Formal>();
        fo.add(formal2);
        RESULT = fo;
    :}
    | {:RESULT = new LinkedList<Formal>();:}
    ;
return ::=
     RETURN exp:e SEMI {:RESULT = e;:}
    |{:RESULT = null;:}
    ;
arguments ::=
    arguments:a COMMA:c exp:e {:a.add(e); RESULT = a;:}
    |exp:e
    {:
        LinkedList<IExp> l = new LinkedList<IExp>();
        l.add(e);
        RESULT = l;
    :}
    |   {:RESULT = new LinkedList<IExp>();:}
    ;
method_declaration ::=
	PUBLIC:p type:t identifier:id LPAREN formals:form RPAREN LBRACE statement_list:sl return:r RBRACE
	{:
        RESULT = new MethodDecl(p.line, p.pos, t, id.getLexeme(), form , new LinkedList<VarDecl>(), sl, r);
	:}
    //|PUBLIC TYPE:t identifier:id LPAREN formals:form RPAREN LBRACE statement_list:sl RBRACE
    //{:RESULT = new MethodDecl(t.getLine(), t.getPos(), t, id.lexeme, form , new LinkedList<VarDecl>(), sl, null);:}
	;
method_list ::=
    method_list:s1 method_declaration:s2
    {: s1.add(s2); RESULT = s1;:}
    |{:RESULT = new LinkedList<MethodDecl>();:}
    ;
class_declaration ::=
    CLASS:c identifier:i LBRACE method_list:m RBRACE
    {:
        RESULT = new TopClassDecl(c.line, c.pos, i.getLexeme(), new LinkedList<VarDecl>(), m);
    :}
    ;
 class_list ::=
    class_list:list class_declaration:c
    {: list.add(c); RESULT = list; :}
    |{: RESULT = new LinkedList<IClassDecl>(); :}
    ;
main_class ::=
        CLASS:op ID:name
            {: /*java.io.PrintStream sout
                    = new java.io.PrintStream(
                        new java.io.FileOutputStream(name.lexeme+".java.s"));
                parser.out = new PrintWriter(sout);*/
                // Check filename is class name, if not exit with error message
                if(!parser.programName.equals(name.lexeme+".java"))
                {
                    System.exit(0);
                }


            :}
        LBRACE PUBLIC STATIC VOID MAIN
        LPAREN STRING LBRACKET RBRACKET ID:param RPAREN
        //LBRACE
          //{:
            /*System.out.println("Generate prolog using avrH.rtl.s");
            InputStream mainPrologue=null;

            BufferedReader reader=null;

            try {
                // The syntax for loading a text resource file
                // from a jar file here:
                // http://www.rgagnon.com/javadetails/java-0077.html
                mainPrologue
                    = this.getClass().getClassLoader().getResourceAsStream(
                        "avrH.rtl.s");
                reader = new BufferedReader(new
                    InputStreamReader(mainPrologue));

                String line = null;
                while ((line = reader.readLine()) != null) {
                  parser.out.println(line);
                }
            } catch ( Exception e2) {
                e2.printStackTrace();
            }
            finally{
                try{                    if(mainPrologue!=null) mainPrologue.close();
                    if(reader!=null) reader.close();
                }
                catch (IOException e) {
                   e.printStackTrace();
                }
            }*/
          //:}
        block_statement:list
          {:
          :}
        RBRACE
          {:
              /*System.out.println("Generate epilog using avrF.rtl.s");
          InputStream mainEpilogue=null;BufferedReader reader2=null;
          try {
          mainEpilogue
              = this.getClass().getClassLoader().getResourceAsStream(
                  "avrF.rtl.s");
          reader2 = new BufferedReader(new
              InputStreamReader(mainEpilogue));

          String line = null;
          while ((line = reader2.readLine()) != null) {
            parser.out.println(line);
          }
          } catch ( Exception e2) {
          e2.printStackTrace();
          }
          finally{
          try{
              if(mainEpilogue!=null) mainEpilogue.close();
              if(reader2!=null) reader2.close();
          }
          catch (IOException e) {
             e.printStackTrace();
          }
      }
            parser.out.flush();*/
            RESULT = new MainClass(op.line, op.pos, name.lexeme,param.lexeme, list);
          :}
    ;
